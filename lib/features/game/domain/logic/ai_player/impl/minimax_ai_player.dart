import 'package:tictactoe/features/game/domain/entities/board.dart';
import 'package:tictactoe/features/game/domain/entities/cell_state.dart';
import 'package:tictactoe/features/game/domain/entities/player.dart';
import 'package:tictactoe/features/game/domain/entities/position.dart';
import 'package:tictactoe/features/game/domain/logic/ai_player/ai_player.dart';
import 'package:tictactoe/features/game/domain/logic/game_rules.dart';

/// CODE generated by AI
/// AI using the Minimax algorithm - plays optimally
/// Will always win or draw, never loses
class MinimaxAiPlayer implements AiPlayer {
  const MinimaxAiPlayer();

  @override
  Position calculateMove(Board board, Player aiPlayer) {
    var bestScore = -double.infinity;
    Position? bestMove;

    for (var row = 0; row < board.size; row++) {
      for (var col = 0; col < board.size; col++) {
        final pos = Position(row: row, col: col);

        if (board.getAt(pos).isEmpty) {
          // Try this move
          final newBoard = board.setAt(pos, CellState.fromPlayer(aiPlayer));
          final score = _minimax(newBoard, 0, false, aiPlayer);

          if (score > bestScore) {
            bestScore = score;
            bestMove = pos;
          }
        }
      }
    }

    if (bestMove == null) {
      throw StateError('No valid move found');
    }

    return bestMove;
  }

  /// Minimax algorithm implementation
  /// Returns the score for the current board state
  double _minimax(Board board, int depth, bool isMaximizing, Player aiPlayer) {
    // Check terminal states
    final winningLine = GameRules.findWinningLine(board);

    if (winningLine != null) {
      final winner = board.getAt(winningLine.first);
      // AI won
      if (winner == CellState.fromPlayer(aiPlayer)) {
        return 10.0 - depth; // Prefer faster wins
      }
      // Opponent won
      return depth - 10.0; // Prefer slower losses
    }

    if (board.isFull) {
      return 0.0; // Draw
    }

    if (isMaximizing) {
      // AI's turn - maximize score
      var bestScore = -double.infinity;

      for (var row = 0; row < board.size; row++) {
        for (var col = 0; col < board.size; col++) {
          final pos = Position(row: row, col: col);

          if (board.getAt(pos).isEmpty) {
            final newBoard = board.setAt(pos, CellState.fromPlayer(aiPlayer));
            final score = _minimax(newBoard, depth + 1, false, aiPlayer);
            bestScore = score > bestScore ? score : bestScore;
          }
        }
      }

      return bestScore;
    } else {
      // Opponent's turn - minimize score
      var bestScore = double.infinity;
      final opponent = aiPlayer.opponent;

      for (var row = 0; row < board.size; row++) {
        for (var col = 0; col < board.size; col++) {
          final pos = Position(row: row, col: col);

          if (board.getAt(pos).isEmpty) {
            final newBoard = board.setAt(pos, CellState.fromPlayer(opponent));
            final score = _minimax(newBoard, depth + 1, true, aiPlayer);
            bestScore = score < bestScore ? score : bestScore;
          }
        }
      }

      return bestScore;
    }
  }
}
